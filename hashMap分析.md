# HashMap 源码分析

## 前面简介
1. 
```text
 该映射通常用作装箱（存储桶）的哈希表，但是当箱太大时，
 它们会转换为TreeNode的箱，每个树的结构与java.util.TreeMap中的结构类似。
 大多数方法尝试使用普通的bin，但是在适用时中继到TreeNode方法（只需检查节点的instance即可）。 
 TreeNodes的Bin可以像其他任何遍历一样使用，但过度填充时还支持更快的查找。
 但是，由于正常使用中的绝大多数垃圾箱都没有人口过多，因此在使用表方法的过程中，
 检查垃圾箱是否存在可能会延迟。
```
2. 
```text
   树箱（即，其元素均为TreeNode的箱）主要由hashCode排序，
   但在有联系的情况下，
   如果两个元素属于相同的“类C实现Comparable <C>”，
   则键入然后使用compareTo方法用于订购。 
   （我们通过反射保守地检查泛型类型以验证*这-参见方法compareableClassFor）。
   当键具有不同的哈希值或可排序时，
   树箱增加的复杂性值得提供最坏情况的O（log n）操作，
   因此，在偶然或恶意使用hashCode（）方法的情况下，
   性能会优雅降低。返回分布不佳的值，以及中许多键共享一个hashCode的值，
   只要它们也是可比较的。 
   （如果这两种方法都不适用，那么与不采取预防措施相比，我们可能会浪费*两倍的时间和空间。
   但是，唯一已知的情况是由于用户的不良编程习惯已经非常缓慢，因此几乎没有什么区别。 ）
```
